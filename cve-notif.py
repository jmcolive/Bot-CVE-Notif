#!/usr/bin/env python
import warnings
import requests
import datetime
import pathlib
import json
import os
import yaml
import vulners
import logging
import sys
from os.path import join
from enum import Enum
from discord import Webhook, RequestsWebhookAdapter
import time

warnings.filterwarnings("ignore", category=DeprecationWarning)

CIRCL_LU_URL = "https://cve.circl.lu/api/query"
CVES_JSON_PATH = join(pathlib.Path(__file__).parent.absolute(), "output/cve-notif.json")
LAST_NEW_CVE = datetime.datetime.now() - datetime.timedelta(days=1)
LAST_MODIFIED_CVE = datetime.datetime.now() - datetime.timedelta(days=1)
TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"

KEYWORDS_CONFIG_PATH = join(pathlib.Path(__file__).parent.absolute(), "config/cve-notif.yaml")

PRODUCT_KEYWORDS = []

class Time_Type(Enum):
    PUBLISHED = "Published"
    LAST_MODIFIED = "last-modified"

################## USE FOR LOGGING ##################

logging.basicConfig(
    format='%(asctime)s,%(msecs)d %(levelname)-8s %(message)s',
    datefmt='%Y-%m-%d:%H:%M:%S',
    level=logging.INFO  # INFO
)

def stdlog(msg):
    '''Standard info logging'''
    logging.info(msg)

def dbglog(msg):
    '''Standard debug logging'''
    logging.debug(msg)

def errlog(msg):
    '''Standard error logging'''
    logging.error(msg)

def critical(msg):
    '''Critical error logging with termination'''
    logging.critical(msg)
    sys.exit()

def warnlog(msg):
    '''Warning error logging'''
    logging.warning(msg)

################## LOAD CONFIGURATIONS ####################

def load_keywords():
    ''' Load keywords from config file '''

    global PRODUCT_KEYWORDS

    with open(KEYWORDS_CONFIG_PATH, 'r') as yaml_file:
        keywords_config = yaml.safe_load(yaml_file)
        dbglog(f"Loaded keywords: {keywords_config}")
        PRODUCT_KEYWORDS = keywords_config["PRODUCT_KEYWORDS"]

def load_lasttimes():
    ''' Load last times from JSON file '''

    global LAST_NEW_CVE, LAST_MODIFIED_CVE

    try:
        with open(CVES_JSON_PATH, 'r') as json_file:
            cves_time = json.load(json_file)
            LAST_NEW_CVE = datetime.datetime.strptime(cves_time["LAST_NEW_CVE"], TIME_FORMAT)
            LAST_MODIFIED_CVE = datetime.datetime.strptime(cves_time["LAST_MODIFIED_CVE"], TIME_FORMAT)
    except Exception as e:
        errlog(f"ERROR, using default last times.\n{e}")
        pass
    stdlog(f"Last new cve: {LAST_NEW_CVE}")
    stdlog(f"Last modified cve: {LAST_MODIFIED_CVE}")

def update_lasttimes():
    ''' Save last times in JSON file '''

    with open(CVES_JSON_PATH, 'w') as json_file:
        json.dump({
            "LAST_NEW_CVE": LAST_NEW_CVE.strftime(TIME_FORMAT),
            "LAST_MODIFIED_CVE": LAST_MODIFIED_CVE.strftime(TIME_FORMAT),
        }, json_file)

################## SEARCH CVES ####################

def get_cves(tt_filter: Time_Type, retries=3, backoff_factor=0.3) -> dict:
    ''' Given the headers for the API retrieve CVEs from cve.circl.lu '''
    now = datetime.datetime.now() - datetime.timedelta(days=1)
    now_str = now.strftime("%d-%m-%Y")
    headers = {
        "time_modifier": "from",
        "time_start": now_str,
        "time_type": tt_filter.value,
        "limit": "100",
    }

    for attempt in range(retries):
        try:
            r = requests.get(CIRCL_LU_URL, headers=headers)
            r.raise_for_status()
            return r.json()
        except requests.exceptions.RequestException as e:
            errlog(f"Request failed (attempt {attempt + 1}): {e}")
            if attempt < retries - 1:
                time.sleep(backoff_factor * (2 ** attempt))
            else:
                return {}

def get_new_cves() -> list:
    ''' Get CVEs that are new '''

    global LAST_NEW_CVE

    cves = get_cves(Time_Type.PUBLISHED)

    filtered_cves, new_last_time = filter_cves(
        cves.get("results", []),
        LAST_NEW_CVE,
        Time_Type.PUBLISHED
    )
    LAST_NEW_CVE = new_last_time
    return filtered_cves

def get_modified_cves() -> list:
    ''' Get CVEs that have been modified '''

    global LAST_MODIFIED_CVE

    cves = get_cves(Time_Type.LAST_MODIFIED)
    filtered_cves, new_last_time = filter_cves(
        cves.get("results", []),
        LAST_MODIFIED_CVE,
        Time_Type.LAST_MODIFIED
    )
    LAST_MODIFIED_CVE = new_last_time
    return filtered_cves

def filter_cves(cves: list, last_time: datetime.datetime, tt_filter: Time_Type) -> list:
    ''' Filter by time the given list of CVEs '''

    filtered_cves = []
    new_last_time = last_time

    for cve in cves:
        cve_time = datetime.datetime.strptime(cve[tt_filter.value], TIME_FORMAT)
        if cve_time > last_time:
            if is_prod_keyword_present(str(cve["vulnerable_configuration"])):
                filtered_cves.append(cve)
            if is_prod_keyword_present(str(cve["assigner"])):
                filtered_cves.append(cve)

        if cve_time > new_last_time:
            new_last_time = cve_time

    return filtered_cves, new_last_time

def is_prod_keyword_present(products: str):
    ''' Given the summary check if any keyword is present '''

    return any(w.lower() in products.lower() for w in PRODUCT_KEYWORDS)

def search_exploits(cve: str) -> list:
    ''' Given a CVE it will search for public exploits to abuse it '''

    # Placeholder for future implementation
    return []

#################### GENERATE MESSAGES #########################

def generate_new_cve_message(cve_data: dict) -> str:
    ''' Generate new CVE message for sending to Slack '''

    message = f"🚨  *{cve_data['id']}*  🚨\n"
    message += f"🔮  *CVSS*: {cve_data['cvss']}\n"
    message += f"📅  *Published*: {cve_data['Published']}\n"
    message += "📓  *Summary*: "
    message += cve_data["summary"] if len(cve_data["summary"]) < 500 else cve_data["summary"][:500] + "..."

    if cve_data["vulnerable_configuration"]:
        message += f"\n🔓  *Vulnerable* (_limit to 10_): " + ", ".join(cve_data["vulnerable_configuration"][:10])

    message += "\n\n🟢 ℹ️  *More information* (_limit to 5_)\n" + "\n".join(cve_data["references"][:5])

    return message

def generate_modified_cve_message(cve_data: dict) -> str:
    ''' Generate modified CVE message for sending to Slack '''

    message = f"📣 *{cve_data['id']}*(_{cve_data['cvss']}_) was modified on {cve_data['last-modified'].split('T')[0]} (_originally published on {cve_data['Published'].split('T')[0]}_)\n"
    return message

def generate_public_expls_message(public_expls: list) -> str:
    ''' Given the list of public exploits, generate the message '''

    if public_expls:
        return "😈  *Public Exploits* (_limit 20_)  😈\n" + "\n".join(public_expls[:20])
    return ""

#################### SEND MESSAGES #########################

def send_slack_message(message: str, public_expls_msg: str):
    ''' Send a message to the Slack group '''

    slack_url = os.getenv('SLACK_WEBHOOK')

    if not slack_url:
        errlog("SLACK_WEBHOOK wasn't configured in the secrets!")
        return

    json_params = {
        "blocks": [
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": message
                }
            },
            {
                "type": "divider"
            }
        ]
    }

    if public_expls_msg:
        json_params["blocks"].append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": public_expls_msg
            }
        })

    requests.post(slack_url, json=json_params)

def send_telegram_message(message: str, public_expls_msg: str):
    ''' Send a message to the Telegram group '''

    telegram_bot_token = os.getenv('TELEGRAM_BOT_TOKEN')
    telegram_chat_id = os.getenv('TELEGRAM_CHAT_ID')

    if not telegram_bot_token:
        warnlog("TELEGRAM_BOT_TOKEN wasn't configured in the secrets!")
        return

    if not telegram_chat_id:
        warnlog("TELEGRAM_CHAT_ID wasn't configured in the secrets!")
        return

    if public_expls_msg:
        message = message + "\n" + public_expls_msg

    message = message.replace(".", "\\.").replace("-", "\\-").replace("(", "\\(").replace(")", "\\)").replace("_", "").replace("[", "\\[").replace("]", "\\]").replace("{", "\\{").replace("}", "\\}").replace("=", "\\=")
    r = requests.get(f'https://api.telegram.org/bot{telegram_bot_token}/sendMessage?parse_mode=MarkdownV2&text={message}&chat_id={telegram_chat_id}')

    resp = r.json()
    if not resp['ok']:
        r = requests.get(f'https://api.telegram.org/bot{telegram_bot_token}/sendMessage?parse_mode=MarkdownV2&text=Error with' + message.split("\n")[0] + f'{resp["description"]}&chat_id={telegram_chat_id}')
        resp = r.json()
        if not resp['ok']:
            errlog("ERROR SENDING TO TELEGRAM: " + message.split("\n")[0] + resp["description"])

def send_discord_message(message: str, public_expls_msg: str):
    ''' Send a message to the Discord channel webhook '''

    discord_webhook_url = os.getenv('DISCORD_WEBHOOK_URL')

    if not discord_webhook_url:
        dbglog("DISCORD_WEBHOOK_URL wasn't configured in the secrets!")
        return

    if public_expls_msg:
        message = message + "\n" + public_expls_msg

    message = message.replace("(", "\\(").replace(")", "\\)").replace("_", "").replace("[", "\\[").replace("]", "\\]").replace("{", "\\{").replace("}", "\\}").replace("=", "\\=")
    webhook = Webhook.from_url(discord_webhook_url, adapter=RequestsWebhookAdapter())
    webhook.send(message)

def send_pushover_message(message: str, public_expls_msg: str):
    ''' Send a message to the Pushover device '''

    pushover_device_name = os.getenv('PUSHOVER_DEVICE_NAME')
    pushover_user_key = os.getenv('PUSHOVER_USER_KEY')
    pushover_token = os.getenv('PUSHOVER_TOKEN')

    if not pushover_device_name:
        warnlog("PUSHOVER_DEVICE_NAME wasn't configured in the secrets!")
        return
    if not pushover_user_key:
        warnlog("PUSHOVER_USER_KEY wasn't configured in the secrets!")
        return
    if not pushover_token:
        warnlog("PUSHOVER_TOKEN wasn't configured in the secrets!")
        return
    if public_expls_msg:
        message = message + "\n" + public_expls_msg

    data = {"token": pushover_token, "user": pushover_user_key, "message": message, "device": pushover_device_name}
    try:
        r = requests.post("https://api.pushover.net/1/messages.json", data=data)
    except Exception as e:
        errlog("ERROR SENDING TO PUSHOVER: " + message.split("\n")[0] + message)

def send_msteams_message(message: str, public_expls_msg: str, title: str, color: str = "000000") -> int:
    ''' Send a message to Microsoft Teams channel '''

    msteams_webhook_url = os.getenv('MSTEAMS_WEBHOOK_URL')

    if not msteams_webhook_url or len(msteams_webhook_url) < 20:
        warnlog("MSTEAMS_WEBHOOK_URL wasn't configured in the secrets!")
        return 0

    if public_expls_msg:
        message = message + "\n" + public_expls_msg

    response = requests.post(
        url=msteams_webhook_url,
        headers={"Content-Type": "application/json"},
        json={
            "themeColor": color,
            "summary": title,
            "sections": [{
                "activityTitle": title,
                "activitySubtitle": message.replace('\n', '<BR>')
            }],
        },
    )

    if response.status_code != 200:
        errlog(f"Failed to send message to Microsoft Teams. Status code: {response.status_code}, Response: {response.text}")
    else:
        stdlog("Message successfully sent to Microsoft Teams")

    return response.status_code  # Should be 200

#################### MAIN #########################

def main():
    print('_____________   _______________            _______   ___________________.______________')
    print('\\_   ___ \\   \\ /   /\\_   _____/            \\      \\  \\_____  \\__    ___/|   \\_   _____/')
    print('/    \\  \\/\\   Y   /  |    __)_    ______   /   |   \\  /   |   \\|    |   |   ||    __) ')
    print('\\     \\____\\     /   |        \\  /_____/  /    |    \\/    |    \\    |   |   ||     \\ ')
    print(' \\______  / \\___/   /_______  /           \\____|__  /\\_______  /____|   |___|\\___  /')
    print('        \\/                  \\/                    \\/         \\/                  \\/1.0')
    print('')

    # Load configured keywords
    load_keywords()

    # Start loading time of last checked ones
    load_lasttimes()

    # Find and publish new CVEs
    new_cves = get_new_cves()
    new_cves_ids = [ncve['id'] for ncve in new_cves]
    stdlog(f"New CVEs discovered: {new_cves_ids}")

    for new_cve in new_cves:
        public_exploits = search_exploits(new_cve['id'])
        cve_message = generate_new_cve_message(new_cve)
        public_expls_msg = generate_public_expls_message(public_exploits)
        send_slack_message(cve_message, public_expls_msg)
        send_telegram_message(cve_message, public_expls_msg)
        send_discord_message(cve_message, public_expls_msg)
        send_pushover_message(cve_message, public_expls_msg)
        send_msteams_message(cve_message, public_expls_msg, "New CVE discovered")

    # Find and publish modified CVEs
    modified_cves = get_modified_cves()
    modified_cves = [mcve for mcve in modified_cves if mcve['id'] not in new_cves_ids]
    modified_cves_ids = [mcve['id'] for mcve in modified_cves]
    stdlog(f"Modified CVEs discovered: {modified_cves_ids}")

    for modified_cve in modified_cves:
        public_exploits = search_exploits(modified_cve['id'])
        cve_message = generate_modified_cve_message(modified_cve)
        public_expls_msg = generate_public_expls_message(public_exploits)
        send_slack_message(cve_message, public_expls_msg)
        send_telegram_message(cve_message, public_expls_msg)
        send_pushover_message(cve_message, public_expls_msg)
        send_msteams_message(cve_message, public_expls_msg, "Modified CVE discovered")

    # Update last times
    update_lasttimes()

if __name__ == "__main__":
    main()
